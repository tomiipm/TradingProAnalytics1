import { ForexSignal, PerformanceStats, WeeklyPerformanceData } from '@/types/forex';

// Generate mock forex signals - this is a placeholder until AI backend is implemented
export const generateMockSignals = (): ForexSignal[] => {
  const standardPairs = ['EUR/USD', 'GBP/USD', 'USD/JPY', 'AUD/USD', 'USD/CAD', 'NZD/USD'];
  const premiumPairs = ['XAU/USD', 'US30', 'EUR/JPY', 'GBP/JPY', 'AUD/JPY', 'NZD/JPY', 'EUR/GBP', 'GBP/CHF', 'EUR/CHF', 'USD/SGD'];
  const signals: ForexSignal[] = [];
  
  // Generate standard signals (available to all users)
  for (let i = 0; i < 6; i++) {
    const pair = standardPairs[i % standardPairs.length];
    signals.push(generateSignal(pair, i, false));
  }
  
  // Generate premium signals (available only to premium users)
  for (let i = 0; i < 10; i++) {
    const pair = premiumPairs[i % premiumPairs.length];
    signals.push(generateSignal(pair, i + 6, true));
  }
  
  // Note: In production, these signals would be generated by a backend service
  // using scikit-learn for data preprocessing and TensorFlow for neural network predictions
  // based on real market data from Financial Modeling Prep API
  
  return signals;
};

// Helper function to generate a single signal
const generateSignal = (pair: string, index: number, isPremium: boolean): ForexSignal => {
  const type = Math.random() > 0.5 ? 'BUY' : 'SELL';
  
  // Adjust price ranges based on the pair
  let basePrice = 1.0;
  if (pair === 'XAU/USD') {
    basePrice = 1900 + Math.random() * 100; // Gold price range
  } else if (pair === 'US30') {
    basePrice = 35000 + Math.random() * 2000; // Dow Jones range
  } else if (pair.includes('JPY')) {
    basePrice = 100 + Math.random() * 50; // JPY pairs range
  } else {
    basePrice = parseFloat((Math.random() * 2 + 1).toFixed(4)); // Standard forex pairs
  }
  
  const entryPrice = basePrice;
  const takeProfit1 = type === 'BUY' 
    ? parseFloat((entryPrice + (entryPrice * 0.01)).toFixed(pair === 'XAU/USD' ? 2 : pair === 'US30' ? 0 : 4)) 
    : parseFloat((entryPrice - (entryPrice * 0.01)).toFixed(pair === 'XAU/USD' ? 2 : pair === 'US30' ? 0 : 4));
  
  const takeProfit2 = type === 'BUY'
    ? parseFloat((takeProfit1 + (entryPrice * 0.01)).toFixed(pair === 'XAU/USD' ? 2 : pair === 'US30' ? 0 : 4))
    : parseFloat((takeProfit1 - (entryPrice * 0.01)).toFixed(pair === 'XAU/USD' ? 2 : pair === 'US30' ? 0 : 4));
  
  const takeProfit3 = index % 3 === 0 ? null : type === 'BUY'
    ? parseFloat((takeProfit2 + (entryPrice * 0.01)).toFixed(pair === 'XAU/USD' ? 2 : pair === 'US30' ? 0 : 4))
    : parseFloat((takeProfit2 - (entryPrice * 0.01)).toFixed(pair === 'XAU/USD' ? 2 : pair === 'US30' ? 0 : 4));
  
  const stopLoss = type === 'BUY'
    ? parseFloat((entryPrice - (entryPrice * 0.005)).toFixed(pair === 'XAU/USD' ? 2 : pair === 'US30' ? 0 : 4))
    : parseFloat((entryPrice + (entryPrice * 0.005)).toFixed(pair === 'XAU/USD' ? 2 : pair === 'US30' ? 0 : 4));
  
  // Generate a random date within the last 10 days
  const date = new Date();
  date.setDate(date.getDate() - Math.floor(Math.random() * 10));
  const timestamp = `${date.toISOString().split('T')[0]} ${date.getHours()}:${date.getMinutes()}`;
  
  // Determine status based on date - UPDATED to use lowercase status values
  let status: 'active' | 'completed' | 'pending';
  const daysAgo = (new Date().getTime() - date.getTime()) / (1000 * 60 * 60 * 24);
  if (daysAgo < 1) {
    status = 'active';
  } else if (daysAgo < 3) {
    status = 'pending';
  } else {
    status = 'completed';
  }
  
  // Calculate potential pips based on entry and take profit
  const pipMultiplier = pair.includes('JPY') || pair === 'XAU/USD' || pair === 'US30' ? 0.01 : 0.0001;
  const pips = Math.round(Math.abs(takeProfit1 - entryPrice) / pipMultiplier);
  
  return {
    id: `signal-${index + 1}`,
    pair,
    type,
    entryPrice,
    takeProfit1,
    takeProfit2,
    takeProfit3,
    stopLoss,
    timestamp,
    isFavorite: Math.random() > 0.7,
    probability: Math.floor(Math.random() * 30) + 70, // 70-99%
    analysis: index % 2 === 0 ? `Technical analysis shows a strong ${type === 'BUY' ? 'bullish' : 'bearish'} trend for ${pair}. RSI indicates ${type === 'BUY' ? 'oversold' : 'overbought'} conditions. [AI-Generated]` : undefined,
    status,
    isPremium,
    pips
  };
};

// Generate mock performance statistics
export const generatePerformanceStats = (): PerformanceStats => {
  const totalTrades = Math.floor(Math.random() * 50) + 100; // 100-150 trades
  const profitTrades = Math.floor(totalTrades * (Math.random() * 0.2 + 0.6)); // 60-80% win rate
  const lossTrades = Math.floor(totalTrades * 0.2); // 20% loss
  const openTrades = totalTrades - profitTrades - lossTrades; // Remaining are open
  
  const winRate = Math.round((profitTrades / (profitTrades + lossTrades)) * 100);
  const accuracy = Math.round(Math.random() * 10 + 70); // 70-80% accuracy
  
  const averageTradesPerDay = (totalTrades / 30).toFixed(1); // Assuming 30 days
  const averageProfitPerDay = (Math.random() * 20 + 10).toFixed(1); // 10-30 pips per day
  const totalPips = Math.floor(parseFloat(averageProfitPerDay) * 30); // Total pips over 30 days
  
  // Generate daily performance data for the last 30 days
  const dailyPerformance = [];
  let cumulativePips = 0;
  
  for (let i = 29; i >= 0; i--) {
    const date = new Date();
    date.setDate(date.getDate() - i);
    const dateString = date.toISOString().split('T')[0];
    
    // Random daily performance between -15 and +40 pips
    const dailyPips = Math.round((Math.random() * 55 - 15) * 10) / 10;
    const trades = Math.floor(Math.random() * 5) + 1; // 1-5 trades per day
    cumulativePips += dailyPips;
    
    dailyPerformance.push({
      date: dateString,
      pips: dailyPips,
      trades: trades,
      cumulativePips: Math.round(cumulativePips * 10) / 10
    });
  }
  
  // Add additional properties for statistics screen
  const averageProfitPerTrade = Math.round(Math.random() * 15 + 15); // 15-30 pips per winning trade
  const averageLossPerTrade = Math.round(Math.random() * 10 + 5); // 5-15 pips per losing trade
  const riskRewardRatio = parseFloat((averageProfitPerTrade / averageLossPerTrade).toFixed(1));
  
  return {
    totalTrades,
    profitTrades,
    lossTrades,
    openTrades,
    winRate,
    accuracy,
    averageTradesPerDay,
    averageProfitPerDay,
    averageProfitPerTrade,
    averageLossPerTrade,
    riskRewardRatio,
    totalPips,
    dailyPerformance
  };
};

// Generate weekly performance data
export const generateWeeklyPerformance = (): WeeklyPerformanceData[] => {
  const days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
  return days.map(day => ({
    day,
    pips: Math.round((Math.random() * 40 - 10) * 10) / 10, // -10 to +30 pips
    trades: Math.floor(Math.random() * 5) + 1 // 1-5 trades per day
  }));
};